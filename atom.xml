<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code Symphony</title>
  
  <subtitle>Clean code reads like well-written prose</subtitle>
  <link href="https://blog.weilence.com/atom.xml" rel="self"/>
  
  <link href="https://blog.weilence.com/"/>
  <updated>2024-06-15T13:32:11.934Z</updated>
  <id>https://blog.weilence.com/</id>
  
  <author>
    <name>Weilence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>调整博客的workflows</title>
    <link href="https://blog.weilence.com/2024/06/15/%E8%B0%83%E6%95%B4%E5%8D%9A%E5%AE%A2%E7%9A%84workflows/"/>
    <id>https://blog.weilence.com/2024/06/15/%E8%B0%83%E6%95%B4%E5%8D%9A%E5%AE%A2%E7%9A%84workflows/</id>
    <published>2024-06-15T03:48:46.000Z</published>
    <updated>2024-06-15T13:32:11.934Z</updated>
    
    <content type="html"><![CDATA[<p>由于调整了域名，我的 blog 需要更新一下域名的配置。具体来说就是使用了 github 的 Custom Domain 功能，需要重新改一下 CNAME 中的内容。</p><p>因为我弄了 Github Action ，所以推送代码之后会自动部署。但是却发布失败了。</p><span id="more"></span><h2 id="发生了什么？"><a href="#发生了什么？" class="headerlink" title="发生了什么？"></a>发生了什么？</h2><p>看了一下 Github Action 的日志，错误发生在 <code>sma11black/hexo-action@v1.0.4</code> 这个 action 上，可能是由于 node 版本太低。</p><p>然后我又看了一下这个 action 的仓库，发现它是 docker 编译，使用的 <code>node 12</code> 的镜像，翻了一下 issue 好像没有人提到这个问题。</p><p>只能自己动手解决了。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>删掉这个 action ，直接使用 node 和 pnpm 的 <code>setup action</code>，加上脚本即可解决。</p><p>我发布 <code>Github Pages</code> 使用的是 deploy 的 git 插件，所以需要提供一个密钥，这个密钥需要设置在环境变量中。</p><p>我没有使用常规的创建目录、写入 id_rsa 的操作，而是使用 ssh-agent 的方式提供 git 的认证。</p><p>所以我的配置如下（部署的配置）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">bash</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    eval &quot;$(ssh-agent -s)&quot;</span></span><br><span class="line"><span class="string">    echo &quot;$&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;&quot; | ssh-add -</span></span><br><span class="line"><span class="string">    git config --global init.defaultBranch master</span></span><br><span class="line"><span class="string">    git config --global user.name xxxxxxxxxxxx</span></span><br><span class="line"><span class="string">    git config --global user.email xxxxxxxxxxxx</span></span><br><span class="line"><span class="string">    pnpm run deploy -g</span></span><br></pre></td></tr></table></figure><p>完整的配置可以看 <a href="https://github.com/weilence/weilence.github.io/blob/master/.github/workflows/deploy.yml">deploy.yml</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于调整了域名，我的 blog 需要更新一下域名的配置。具体来说就是使用了 github 的 Custom Domain 功能，需要重新改一下 CNAME 中的内容。&lt;/p&gt;
&lt;p&gt;因为我弄了 Github Action ，所以推送代码之后会自动部署。但是却发布失败了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="https://blog.weilence.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>RxJS 迁移 toPromise 到 lastValueFrom</title>
    <link href="https://blog.weilence.com/2024/01/07/RxJS-%E8%BF%81%E7%A7%BB-toPromise-%E5%88%B0-lastValueFrom/"/>
    <id>https://blog.weilence.com/2024/01/07/RxJS-%E8%BF%81%E7%A7%BB-toPromise-%E5%88%B0-lastValueFrom/</id>
    <published>2024-01-07T06:39:29.000Z</published>
    <updated>2024-06-15T13:32:11.930Z</updated>
    
    <content type="html"><![CDATA[<p>最近在给别人维护的一份 Angular 的代码需要升级版本，升级完成后，lint 给了大量的 toPromise warning，看的我十分难受。但要一个一个手动改也十分头疼，查看 RxJS 官方的说明，也没有提供工具迁移，于是只能自己开发一个。</p><p>本文记录了开发过程，文末附带这个工具的 github 链接。</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>代码迁移实际上就是文本替换，但不能直接使用字符串查找替换的方法解决，因为代码是有上下文的，我们需要依赖这个上下文才能找到具体要替换的位置，已经替换后的样子，所以哪怕是依靠正则替换也是不行的。</p><p>这里可以通过编译原理的知识可以得知，代码是解析成 AST（语法树）。我们可以遍历 AST 找到特定特征的代码。</p><p>最开始是想直接使用 typescript 这个包来完整这个解析，但当我做完之后，发现回写到源代码时，丢失了一些空行，这是无法接收的。</p><p>于是通过询问 chatgpt 得知可以使用 ts-morph 解析。看了一下文档，这个库也是基于 typescript 的，但通过它回写却没有出现丢失空行的问题，应该是之前直接使用 typescript 姿势不对，但这已经不重要了，ts-morph 确实比直接用 typescript 方便很多，而且至少官方有示例，typescript 是一个例子都没有。</p><p>这个项目本身使用 ts 开发，为了方便使用，这里安装 ts-node 直接运行 ts 代码，避免先编译再运行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Project</span>, ts &#125; <span class="keyword">from</span> <span class="string">&#x27;ts-morph&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dir = process.<span class="property">argv</span>?.[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> (!dir) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Please specify a directory&#x27;</span>)</span><br><span class="line">  process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> project = <span class="keyword">new</span> <span class="title class_">Project</span>()</span><br><span class="line">project.<span class="title function_">addSourceFilesAtPaths</span>(dir)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> sourceFile <span class="keyword">of</span> project.<span class="title function_">getSourceFiles</span>()) &#123;</span><br><span class="line">  <span class="keyword">let</span> hasChange = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  sourceFile.<span class="title function_">transform</span>(<span class="function">(<span class="params">traversal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> node = traversal.<span class="title function_">visitChildren</span>()</span><br><span class="line">    <span class="keyword">if</span> (ts.<span class="title function_">isCallExpression</span>(node) &amp;&amp; ts.<span class="title function_">isPropertyAccessExpression</span>(node.<span class="property">expression</span>) &amp;&amp; node.<span class="property">expression</span>.<span class="property">name</span>.<span class="title function_">getText</span>() === <span class="string">&#x27;toPromise&#x27;</span>) &#123;</span><br><span class="line">      hasChange = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> ts.<span class="property">factory</span>.<span class="title function_">createCallExpression</span>(</span><br><span class="line">        ts.<span class="property">factory</span>.<span class="title function_">createIdentifier</span>(<span class="string">&#x27;lastValueFrom&#x27;</span>),</span><br><span class="line">        [],</span><br><span class="line">        [node.<span class="property">expression</span>.<span class="property">expression</span>],</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!hasChange)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> importDeclaration = sourceFile.<span class="title function_">getImportDeclaration</span>(<span class="string">&#x27;rxjs&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (!importDeclaration) &#123;</span><br><span class="line">    sourceFile.<span class="title function_">addImportDeclaration</span>(&#123;</span><br><span class="line">      <span class="attr">moduleSpecifier</span>: <span class="string">&#x27;rxjs&#x27;</span>,</span><br><span class="line">      <span class="attr">namedImports</span>: [<span class="string">&#x27;lastValueFrom&#x27;</span>],</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = importDeclaration.<span class="title function_">getNamedImports</span>().<span class="title function_">findIndex</span>(<span class="function"><span class="params">namedImport</span> =&gt;</span> namedImport.<span class="title function_">getName</span>() === <span class="string">&#x27;lastValueFrom&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>)</span><br><span class="line">      importDeclaration.<span class="title function_">addNamedImport</span>(<span class="string">&#x27;lastValueFrom&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fs.<span class="title function_">writeFileSync</span>(sourceFile.<span class="title function_">getFilePath</span>(), sourceFile.<span class="title function_">getFullText</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上一共也没几行，主要解释一下定位特征和替换。</p><p>首先要知道，对于<code>a.b.c.toPromise()</code>这样的代码，会生成如下的 AST</p><img src="/2024/01/07/RxJS-%E8%BF%81%E7%A7%BB-toPromise-%E5%88%B0-lastValueFrom/1.png" class=""><p>而对于<code>lastValueFrom(a.b.c)</code>这样的代码，则需要这样创建 AST</p><img src="/2024/01/07/RxJS-%E8%BF%81%E7%A7%BB-toPromise-%E5%88%B0-lastValueFrom/2.png" class=""><p>你可以直接在 <a href="https://ts-ast-viewer.com/">https://ts-ast-viewer.com/</a> 上可视化的看到 AST，非常方便。</p><p>另外需要处理的是，如果原来的文件中没有 import rxjs 这个包，或者 import 了但是没有导入 lastValueFrom 这个函数，还需要添加一下 import。</p><h2 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h2><p><a href="https://github.com/weilence/migrate-to-promise">https://github.com/weilence/migrate-to-promise</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在给别人维护的一份 Angular 的代码需要升级版本，升级完成后，lint 给了大量的 toPromise warning，看的我十分难受。但要一个一个手动改也十分头疼，查看 RxJS 官方的说明，也没有提供工具迁移，于是只能自己开发一个。&lt;/p&gt;
&lt;p&gt;本文记录了开发过程，文末附带这个工具的 github 链接。&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端" scheme="https://blog.weilence.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Angular" scheme="https://blog.weilence.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>Windows使用PXE安装Manjaro</title>
    <link href="https://blog.weilence.com/2022/09/19/Windows%E4%BD%BF%E7%94%A8PXE%E5%AE%89%E8%A3%85Manjaro/"/>
    <id>https://blog.weilence.com/2022/09/19/Windows%E4%BD%BF%E7%94%A8PXE%E5%AE%89%E8%A3%85Manjaro/</id>
    <published>2022-09-19T13:27:57.000Z</published>
    <updated>2024-06-15T13:32:11.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在重构之前的一个项目，项目中有一个定时备份数据库的功能。之前的项目使用的python，用的python的第三方类库+mysqldump实现，新版考虑到备份功能不应该依赖程序实现，所以采用crontab+mysqldump实现。</p><p>然后问题就来了，不采用linux的命令，使用windows开发体验还过得去，无非就是不能用cgo而已，但毕竟<a href="https://dave.cheney.net/2016/01/18/cgo-is-not-go">cgo is not go</a>，所以也并不影响开发。</p><p>之前也想过采用wsl去做，但wsl毕竟也不是linux，systemctl很难用，且crontab虽然可以编辑但实际上并不会执行（查资料是说依赖了linux的功能但wsl不支持，类似于systemctl），导致debug困难，而且我目前也不擅长写shell脚本，没有那么自信不测试直接上线。</p><p>于是就想换一个linux系统，上周四晚上就带着电脑回家，然而发现忘记带U盘了，网购也来不及，人生地不熟的也很难借一个闲置U盘。我另有一台自己的Windows笔记本，于是决定用PXE给公司发的笔记本重装一下linux。</p><span id="more"></span><h2 id="PXE简单说明"><a href="#PXE简单说明" class="headerlink" title="PXE简单说明"></a>PXE简单说明</h2><p>PXE是一种可以通过网络启动的技术，有无盘和有盘两种。无盘的典型就是网吧，所有的机器都是无盘运行软件的。有盘就可以通过网络脱机安装系统，不需要人工干预，适用于企业批量安装系统。</p><p>PXE简单来说依赖两个技术：DHCP和TFTP。如果是安装系统的话，取决于系统安装的Bootloader，可能也需要HTTP或者其他协议用来传输安装中使用的数据。</p><p>流程大概是</p><ol><li>Client进入PXE启动后，广播DHCP到局域网，询问有没有支持PXE的DHCP</li><li>支持PXE的DHCP协议会回复Client，携带Bootloader的元数据</li><li>Client采用TFTP协议获取Bootloader</li><li>运行Bootloader</li></ol><p>运行Bootloader后就跟正常的安装流程就是一样的了，但大部分的Bootloader在安装过程中会使用到http协议获取系统的安装文件，所以Server端还需要运行http服务器</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>如果手动去部署DHCP、TFTP、Http Server未免也太痛苦了，所以有人就开发了一整套的功能，windows上直接下载<a href="https://www.vercot.com/~serva/download.html">Serva</a>，社区版<strong>据说</strong>会50分钟就要重启一次，但单次安装过程肯定不会超过50分钟。</p><p>下载完成后直接解压出<code>Serva64.exe</code>，直接运行即可。为了后续方便操作，在桌面上建一个Serva的文件夹，把这个exe放进去。</p><p>我本机的环境是1个路由器，2台笔记本，Windows的笔记本通过wifi连接路由器，待安装的笔记本通过网线连接路由器</p><p>运行Server64后，点击标题栏左侧的小图标，出现一个menu，点击memu里面的settings</p><img src="/2022/09/19/Windows%E4%BD%BF%E7%94%A8PXE%E5%AE%89%E8%A3%85Manjaro/1.jpg" class=""><p>然后你需要修改以下3个tab，HTTP和TFTP均选择新建的这个Serva文件夹</p><img src="/2022/09/19/Windows%E4%BD%BF%E7%94%A8PXE%E5%AE%89%E8%A3%85Manjaro/2.jpg" class=""><img src="/2022/09/19/Windows%E4%BD%BF%E7%94%A8PXE%E5%AE%89%E8%A3%85Manjaro/3.jpg" class=""><img src="/2022/09/19/Windows%E4%BD%BF%E7%94%A8PXE%E5%AE%89%E8%A3%85Manjaro/4.jpg" class=""><p>然后点击保存，再关闭软件，重启启动，就会出现BM、NWA_PXE、WIA_RIS、WIA_WDS四个文件夹</p><p>如果你是安装Linux，把NWA_PXE共享，并且设置共享名为NWA_PXE_SHARE，<strong>Windows的PXE安装不适用，请自行阅读官方文档</strong></p><img src="/2022/09/19/Windows%E4%BD%BF%E7%94%A8PXE%E5%AE%89%E8%A3%85Manjaro/5.jpg" class=""><p>将你下载的Linux镜像解压后方到NWA_PXE文件夹，例如我的就放到<code>xxx/Serva/manjaro-kde-21.3.7-220816-linux515</code>里面，然后在这个文件夹里放一个<code>ServaAsset.inf</code>文件，内容在<a href="https://www.vercot.com/~serva/an/NonWindowsPXE3.html">https://www.vercot.com/~serva&#x2F;an&#x2F;NonWindowsPXE3.html</a>的<code>3.22 Manjaro Linux</code>中。</p><p>你不需要修改这个文件中版本号之类的东西，版本号只用于安装过程中的显示，不影响安装过程。也不需要去下载INITRD_N28.1，除非你安装Manjaro Linux 17。</p><p>你需要做的就是修改kernel_bios、append_bios、kernel_efi64、append_efi64中的那些文件路径，部分情况下可能有少量的不同，自行调整一下。$HEAD_DIR$是这个镜像文件家的名称，我的例子中是<code>manjaro-kde-21.3.7-220816-linux515</code></p><p>然后关闭软件，有4点注意事项切记</p><ol><li>关闭vpn</li><li>关闭防火墙</li><li>不要忘记共享文件夹</li><li>HTTP、TFTP配置的目录不要配错</li></ol><p>确认无误后启动软件</p><p>然后就可以重启待安装的笔记本，选择PXE启动，然后跟正常的安装过程一样。</p><p>最后有一点要注意：Bootloader安装系统的工程中，可能会出现文件找不到的情况，这是因为安装程序中的http路径和你在Serva中选择的文件路径不一致。我就碰到了安装程序通过http读取文件的时候少了<code>Serva\NWA_PXE</code>这一段，所以我在<strong>Bootloader中</strong>将<code>xxxx\Serva\NWA_PXE</code>下的文件手动移动到了<code>xxxx\</code>下。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>整个安装过程其实还是毕竟简单的，但是我本机上安装了open vpn踩了坑，浪费了大量的时间找资料。</p><p>最近一直沉迷看剧、看小说，可以说是过的十分丰富了，每当要下定决心不看了去学习，还是没成功，大概是跟胡适打牌类似吧</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;最近在重构之前的一个项目，项目中有一个定时备份数据库的功能。之前的项目使用的python，用的python的第三方类库+mysqldump实现，新版考虑到备份功能不应该依赖程序实现，所以采用crontab+mysqldump实现。&lt;/p&gt;
&lt;p&gt;然后问题就来了，不采用linux的命令，使用windows开发体验还过得去，无非就是不能用cgo而已，但毕竟&lt;a href=&quot;https://dave.cheney.net/2016/01/18/cgo-is-not-go&quot;&gt;cgo is not go&lt;/a&gt;，所以也并不影响开发。&lt;/p&gt;
&lt;p&gt;之前也想过采用wsl去做，但wsl毕竟也不是linux，systemctl很难用，且crontab虽然可以编辑但实际上并不会执行（查资料是说依赖了linux的功能但wsl不支持，类似于systemctl），导致debug困难，而且我目前也不擅长写shell脚本，没有那么自信不测试直接上线。&lt;/p&gt;
&lt;p&gt;于是就想换一个linux系统，上周四晚上就带着电脑回家，然而发现忘记带U盘了，网购也来不及，人生地不熟的也很难借一个闲置U盘。我另有一台自己的Windows笔记本，于是决定用PXE给公司发的笔记本重装一下linux。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术" scheme="https://blog.weilence.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="PXE" scheme="https://blog.weilence.com/tags/PXE/"/>
    
  </entry>
  
  <entry>
    <title>Windows在wsl2中安装archlinux桌面应用</title>
    <link href="https://blog.weilence.com/2022/07/28/Windows%E5%9C%A8wsl2%E4%B8%AD%E5%AE%89%E8%A3%85archlinux%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
    <id>https://blog.weilence.com/2022/07/28/Windows%E5%9C%A8wsl2%E4%B8%AD%E5%AE%89%E8%A3%85archlinux%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/</id>
    <published>2022-07-28T14:25:38.000Z</published>
    <updated>2024-06-15T13:32:11.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装wsl2"><a href="#安装wsl2" class="headerlink" title="安装wsl2"></a>安装wsl2</h2><p>首先你需要安装 wsl2 ，开启的方法为在【控制面板】-【程序与功能】-【启用或关闭 Windows 功能】中勾选 【适用于 Linux 的 Windows 子系统</p><img src="/2022/07/28/Windows%E5%9C%A8wsl2%E4%B8%AD%E5%AE%89%E8%A3%85archlinux%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/2.jpg" class=""><p>然后打开命令行，运行命令<code>wsl --update</code>，等待更新完成</p><span id="more"></span><h2 id="安装-ArchWSL"><a href="#安装-ArchWSL" class="headerlink" title="安装 ArchWSL"></a>安装 ArchWSL</h2><p>前往 <a href="https://github.com/yuk7/ArchWSL/releases">https://github.com/yuk7/ArchWSL/releases</a> ，然后下载新版本的 Arch.zip</p><p>里面应当包含 Arch.exe 和 rootfs.tar.gz 两个文件，将他们解压到你想存放的虚拟机文件的位置，然后双击 Arch.exe</p><p>安装完成后如图所示：</p><img src="/2022/07/28/Windows%E5%9C%A8wsl2%E4%B8%AD%E5%AE%89%E8%A3%85archlinux%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/1.jpg" class=""><p>安装完成后，目录中应该会多出一个 ext4.vhdx 文件，这个是虚拟机的磁盘文件</p><p>如果在后面的步骤中操作失败，可以打开控制台，输入<code>wsl --unregister Arch</code>删除 archlinux ，然后重新安装重新操作</p><h2 id="更新-ArchLinux"><a href="#更新-ArchLinux" class="headerlink" title="更新 ArchLinux"></a>更新 ArchLinux</h2><p>再次双击 Arch.exe ，这次会直接进入 archlinux 中，初次进入会进行一些初始化</p><p>初始化完成后， archlinux 就已经安装好可以使用了，但这里只能命令行，并且 D-Bus 和 systemctl 是无法使用的</p><p>然后可以进一步操作，我这里已经写好了脚本，可以下载下来直接使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载脚本</span></span><br><span class="line">curl -fsSL https://raw.githubusercontent.com/Weilence/auto/main/shell/arch-wsl.sh -o arch-wsl.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加执行权限</span></span><br><span class="line">chmod +x arch-wsl.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行脚本</span></span><br><span class="line">source arch-wsl.sh</span><br></pre></td></tr></table></figure><p><strong>安装过程中如果出现询问 fakeroot 是否需要安装，务必不要安装</strong>，除此以外的其他地方可以全部直接按回车</p><p>执行脚本后，按照1、2、3、4的顺序执行脚本。</p><p>虽然0代表1234按顺序执行，但如果你是第一次使用，不建议这样做。</p><h2 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h2><p>至此，你已经安装完成，你的开始菜单中可能会出现一个 Arch 文件夹，里面会包含一些 archlinux 中的应用，可以直接点击运行</p><p>当前应该有输入法相关的配置</p><p>现在你可以安装 gedit 尝试 archlinux 的 GUI 程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 安装gedit</span></span></span><br><span class="line">pacman -S gedit</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 打开gedit，你也可以在开始菜单中点击 gedit</span></span></span><br><span class="line">gedit</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 删除gedit及依赖</span></span></span><br><span class="line">pacman -Rsu gedit</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;安装wsl2&quot;&gt;&lt;a href=&quot;#安装wsl2&quot; class=&quot;headerlink&quot; title=&quot;安装wsl2&quot;&gt;&lt;/a&gt;安装wsl2&lt;/h2&gt;&lt;p&gt;首先你需要安装 wsl2 ，开启的方法为在【控制面板】-【程序与功能】-【启用或关闭 Windows 功能】中勾选 【适用于 Linux 的 Windows 子系统&lt;/p&gt;
&lt;img src=&quot;/2022/07/28/Windows%E5%9C%A8wsl2%E4%B8%AD%E5%AE%89%E8%A3%85archlinux%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8/2.jpg&quot; class=&quot;&quot;&gt;

&lt;p&gt;然后打开命令行，运行命令&lt;code&gt;wsl --update&lt;/code&gt;，等待更新完成&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术" scheme="https://blog.weilence.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="wsl" scheme="https://blog.weilence.com/tags/wsl/"/>
    
    <category term="archlinux" scheme="https://blog.weilence.com/tags/archlinux/"/>
    
  </entry>
  
</feed>
